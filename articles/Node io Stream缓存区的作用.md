# Node IO 缓存区的作用

node 提供了readFile，createReadStream，writeFile，createWriteStream来对文件进行读写，但是文件的内容并不是直接到用户或者磁盘的手中，而是中间会有一个缓存区，这个缓存区是干什么的，为什么我们需要这个缓存区，这就是本篇博文需要讨论的问题。

### 为什么我们需要缓存区 

在我们读取文件的时候，根据程序提取需要启动的设备的相对号，然后由操作系统根据设备的使用情况和损坏情况拿到需要启动的设备的绝对号，决定需要启动哪个io设备，此时，cpu会通知相应的通道，通道通过CAW拿到相应的通道指令，再由通道通知相应的设备管理器，启动设备。

简单的流程大概如下

![这里写图片描述](http://img.blog.csdn.net/20171208203812441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFvRGFXYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

假如用户需要读取在磁盘上的data.txt 文件，如果直接读取内容到内存的话，那么首先node主进程会先指明需要读取文件，此时，系统会产生一个中断，node 主进程挂起进入等待状态，cpu通知通道通知相应的io设备，io设备读取到相应的数据之后传送到内存，这时，系统又会产生一个中断，刚刚挂起的node进程占用cpu，读取相应的数据进行处理，由于io设备是一个磁盘块一个磁盘块读取的，因此，io设备会等待node进程处理完毕数据然后再回去传送下一块。这样做的效率并不高，于是在中间建立一个缓存区，这时，当io设备把数据读取到缓存区时，io设备可以不用等待node进程处理完毕，直接去读取下一块数据，这样无疑提高了效率。那么，当node 进行写文件的时候又是怎么一个流程呢，node 进程会先一段数据一段数据的写（仅仅用于io流），当缓存区写满后，就会一次性的写到磁盘。

值得注意的是，readFile与WriteFile会将文件视为一个整体，一次性读入缓存区，然后再由用户进程读取缓存区里的内容。在这个期间，Node将不能执行其他任何操作。使用io流的好处是，readStream和writeStream不会将文件视为一个整体，而是一段一段的去读写，因此，node可以在读写的过程中进行操作。并且node还提供了一些事件来用于描述当数据被写入缓存区的时候的一些情况。

```
drain 当缓存区满的时候，数据被一次性写入磁盘，触发drain 事件
finish 当end方法被调用，数据被全部写入缓存区时触发
pipe 当用于读取数据的对象的pipe方法被调用时触发
unpipe 当用于读取数据的对象的unpipe方法被调用时触发
error 当写入数据的过程中产生错误时触发
```

