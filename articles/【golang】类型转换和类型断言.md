# 【golang】类型转换和类型断言

类型断言是什么，类型断言和类型转换有什么区别，这个问题以前我也常常分不清楚。为了帮助和我有一样疑问的人，我决定得写一篇关于这方面的博文，介绍一下golang中的类型断言和类型转换的区别，在JavaScript的超集，也同样有类型断言的概念。这篇简短的博文就是帮助大家解答这个疑问，我会尽量短的说清楚，我理解的类型转换和类型断言的区别是什么。

## 什么是类型转换

类型转换在很多静态类型的语言中都会有的概念，类型转换通常分为显示类型转换和隐式类型转换。强制类型转换形如:

```
f := 11.22
i := int(f)
```

例如有个float32的变量被赋值为11.22，现在我们想去掉小数部分，最简单的方法就是将float32转换为int32。

简单来说，强制类型转换就是你要从一个类型强制转换到另一个类型。适用于一些基本类型，比如int, float之类等等。但在golang中，类型匹配是相当严格的，很多时候编译器不会帮你去做，所以大多数的情况下，我们还是会做一些显示的类型转换。

比如这段看起来在其它静态类型语言中毫无问题的代码片段，在golang中编译期就会报错，golang会强制让你做类型转换。

```
var i int = 1
var f float64 = i
```

接下来看看隐式的类型转换。golang中的隐式类型转换主要存在于运行时。比如：

```
var w io.Writer = os.Stdout
```

这里将*File类型赋值给了io.Writer类型，在运行时会做一个隐式的类型转换。

## 什么是断言

在了解什么是类型断言之前，先来了解一下断言是什么

![这里写代码片](https://img-blog.csdn.net/20180620140701804?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb0RhV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这是尼克杨吗？

是

那么断言成功，反之断言失败。

简而言之，断言就是对一种条件进行假设，如果这是尼克杨，那么我要要干嘛？如果这不是尼克杨又怎样？
随之，类型断言就是对类型进行一种假设。

这里拿Typescript来说个事，在TS里我们很多时候会用到一种类型叫联合类型，联合类型A | B可以理解为它可以是A类型或者是B类型。实际例子：

```
let zhangsan:Student | null //表示zhangsan是一个Student或者null类型
```

我们需要使用zhangsan的时候，可以使用类型断言

```
if(zhangsan) zs = <Student>zhangsan
//或者
if(zhangsan) zs = zhangsan as Student
```

在golang中的类型断言和Typescript中的第二种类型断言比较相像。在golang中形如

```
x.(T)
```

x是一种接口类型，T可以是一种具体的类型也可以是一种接口类型

## golang为什么需要类型断言

为此，我们思考一个问题，为什么Golang需要类型断言，golang中对类型的要求十分严格，而且golang中也没有Typescript中的联合类型，好像一切类型都是固定不变的，有了强制转换类型，为什么还需要类型断言呢？

在Golang中，接口类型是能够隐式转换的。看一个具体的例子:

```
var w io.Writer = os.Stdout
```

w的类型为io.Writer，但是它被赋值了\*File，这是Golang帮助我们做了一次类型转换。这次类型转换是在运行时的，编译时并不能确定下来。在运行时，这个接口值的类型被赋值为了\*File，与此同时，值也被赋值为了os.Stdout。

上述说明了一个问题，接口值的类型是不固定的！因为它的类型是要在运行时才能确定下来，这需要看它的动态值的类型才能确定。这就是需要类型断言的原因了。

再看一个具体的例子

```
var w io.Writer = os.Stdout
```

这条语句执行过后，w只会拥有write方法，但是原本的\*File不止拥有write方法，应该还拥有read方法，同时，它也是io.ReadWriter接口的一个实例。如果这时候我们想使用read方法怎么办，那就需要类型断言了。

```
rw := w.(io.ReadWriter)
```

这里将w断言为ReadWriter类型。断言类型为一个接口。暴露了\*File的read和write方法

## 类型断言的检查机制是怎样的

于是我们想了解Golang的类型断言的检查机制是怎样的，换句话说，Golang到底是如何来判断断言是否成功的。

首先明确的是x必须为一个接口类型，而T可以是一个具体的类型也可以是一个接口类型。下面我们分情况讨论。

**1.当T为一个接口类型时**

当T为一个接口时，首先会判断x的动态值是否符合T这个接口，如果符合的话，断言成功，反之断言失败，断言失败时会抛出一个panic异常。但是如果类型断言出现在一个预期有两个结果的赋值操作中，那么断言失败不会抛出panic异常，而是用一个bool值标识是否断言成功。

```
var w io.Writer = os.Stdout 
b, ok := w.(*bytes.Buffer) 
```

为了健壮性，我们应该对ok返回的结果进行处理。标识是否断言成功。

```
var w io.Writer = os.Stdout 
if b, ok := w.(*bytes.Buffer);!ok {
    fmt.Fprintf(os.Stderr, "断言失败")
} else {
    //TODO
}
```

对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分（Go Programing Language）

**当T为一个具体类型时**

当T为一个具体类型时，会先检查x的动态值的类型是否为T，如果为T则断言成功，如果不为T，则断言失败。

具体类型的类型断言从它的操作对象中获得具体的值（Go Programing Language）

**当x为nil**

最后再简单的说一下x为nil的情况，当x为nil时，那么不论断言类型是任何类型，都会断言失败