# 【操作系统】主存重定位

在多道程序设计中，作业想要执行必须占取cpu资源，在此之前，会经过作业调度进入主存区，而往往有很多程序同时经过作业调度进入主存区，用户往往不能预先知道它的作业被装在主存区的什么位置，因此，我们引入了逻辑地址空间的概念，用户可以认为自己的程序和数据放在从0地址开始的一组连续地址空间中。而在主存区访问的地址是物理地址，因此，在把作业载入主存区的时候，需要把逻辑地址转换为物理地址。转换的过程称作重定位，具体怎么转换有两个方式，第一个是静态重定位，第二个是动态重定位。

### 1.静态重定位

在作业载入主存区之前，直接一次性把逻辑地址转换为物理地址，在作业已经载入主存区的时候，已经是用物理地址指示了，运行的时候也不用再次转换了，当然，就此看来，静态重定位是在载入主存区之前一次性被转换，因此它不支持程序浮动。

### 2.动态重定位

在作业开始执行之前都不再转换，而是等待作业执行过程中，每执行一条指令转换一次，作业有一个基址寄存器，储存当前作业在主存区的首地址，因此转换的公式可以简单的看为：

```
物理地址 = 基址寄存器储存的地址 + 逻辑地址
```

因为动态重定位是动态执行的，当需要程序浮动时，实际只用改变基址寄存器储存的地址，因此，动态重定位是支持程序浮动的。