# Perl6 Lambda

Lambda 一直是函数式编程津津乐道的东西，从 `Haskell` 再到许多编程语言为了支持函数式，引入了 `Lambda`，Perl6 也支持 `Lambda`，但是 Perl6 中的 `Lambda` 好像又不太一样。

我理解的 Perl6 中的 `Lambda` 其实是一个可以传入参数的代码块，而并不是一个 "正宗" 的 `subroutine`

```perl
say -> {}.WHAT; # (Block)
say sub {}.WHAT; # (Sub)
```

在使用 WHAT 方法的时候，打印出来的是 `Block` 和 `Sub` 可见，Perl6 的 `lambda` 确实是一个代码块，因此你可以简写到什么地步呢？

```perl
-> $cb {$cb()}({say "hello"}) # hello
```

这是一个立即执行函数，为 `lambda` 接收另一个 `lambda` 为参数，内部执行

有一定经验的同学一定都写过 `Fibonacci`，当然，那是最经典的递归练习了，如果还不知道的同学可以移步 [求解 Fibonacci 的正确姿势](https://blog.csdn.net/HaoDaWang/article/details/87813727)，这里不再赘述。

来看一个比较刺激的版本，Perl6 实现 `Fibonacci`

```perl
my @fibonacci = 1, 1, * + * ... *;
```

比如我们要 `fibonacci`  的第 46项

```perl
say @fibonacci[10000]; 
```

output:

```
54438373113565281338734260993750380135389184554695967026247715841208582865622349017083051547938960541173822675978026317384359584751116241439174702642959169925586334117906063048089793531476108466259072759367899150677960088306597966641965824937721800381441158841042480997984696487375337180028163763317781927941101369262750979509800713596718023814710669912644214775254478587674568963808002962265133111359929762726679441400101575800043510777465935805362502461707918059226414679005690752321895868142367849593880756423483754386342639635970733756260098962462668746112041739819404875062443709868654315626847186195620146126642232711815040367018825205314845875817193533529827837800351902529239517836689467661917953884712441028463935449484614450778762529520961887597272889220768537396475869543159172434537193611263743926337313005896167248051737986306368115003088396749587102619524631352447499505204198305187168321623283859794627245919771454628218399695789223798912199431775469705216131081096559950638297261253848242007897109054754028438149611930465061866170122983288964352733750792786069444761853525144421077928045979904561298129423809156055033032338919609162236698759922782923191896688017718575555520994653320128446502371153715141749290913104897203455577507196645425232862022019506091483585223882711016708433051169942115775151255510251655931888164048344129557038825477521111577395780115868397072602565614824956460538700280331311861485399805397031555727529693399586079850381581446276433858828529535803424850845426446471681531001533180479567436396815653326152509571127480411928196022148849148284389124178520174507305538928717857923509417743383331506898239354421988805429332440371194867215543576548565499134519271098919802665184564927827827212957649240235507595558205647569365394873317659000206373126570643509709482649710038733517477713403319028105575667931789470024118803094604034362953471997461392274791549730356412633074230824051999996101549784667340458326852960388301120765629245998136251652347093963049734046445106365304163630823669242257761468288461791843224793434406079917883360676846711185597501
```

打印出的运行时间 `0.25212712s`，1s 都没用到！真的太刺激了。

因为 `Perl6` 中允许创建一个无限的数组，上面的 `@fibonacci` 就是一个无限的数组，使用了惰性队列，只有当用到的时候才会去计算，其实是在逻辑上是无限的，但是实际不是，数组都是有容量的。

`* + *` 是一个 `WhatEver Code`，但是它可以当作函数去调用，但实际上它们是两种不同的类型，是不兼容的两种类型。此外 `*` 不做运算的时候是 `WhatEver` 类型，它可以代表 `Inf`，这就是为什么是创建的无限容量的数组的原因了。

