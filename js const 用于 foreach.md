# JS Const 关键字用于 Foreach

对于 `const` 相信大家已经用的熟的不能再熟了，这里想谈论一下关于我的疑问对于 `const`

按照惯例还是放个小的代码片

```javascript
for(const i = 0;i < n;i++) {
  console.info(i) // error
}
```

上面的代码不能正常运行，这是正常的，在我们的预料范围之内

`const` 对于在 `stack` 上存储的数据向来都是比较 "严格" 的，但是有的情况却不然，比如下面这段代码可能会打破你的认知

```js
const arr = [1, 2, 3]

for(const val of arr) {
	console.info(val)  // 1, 2, 3
}
```

上面的代码依然能正常跑起来

长久以来，用 `foreach` 的时候都没有注意到这个问题，今天还是写一篇博文来记录一下这个神奇的瞬间

进入正题，上面的代码之所以能跑起来，是因为 `foreach` 中的 `const val of arr` 是会在每次迭代的时候在新作用域里都执行一次，所以这里并没有违背 `const`，不仅仅是 `for ... of`，凡是 `foreach` 都是能正常工作的，比如上面的代码换成 `for...in` 也是能正常工作。

但是为什么第一个代码片却不能正常执行呢？答案是因为 `for` 的初始化只会在开始迭代之前执行一次，以后的每次迭代都不会再去执行初始化声明，所以自然是不能正常工作的。

为什么当初这样设计？ 个人拙见。是因为 `foreach` 不会有给迭代变量赋值的场景，所以你照下面这样执行，也是没有副作用的

```js
for(let v of arr){
  console.info(v)
  v = 1
}
```

还有一个原因可能是因为简化 `iterator` 的实现，每次迭代不用再去关心迭代变量带来的副作用

小记。

